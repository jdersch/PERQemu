
PERQ Video Display Notes
========================

Some details recorded here for posterity.  These are the obscure little bits
of information about display timing gleaned from various hardware and microcode
sources as summarized below, and implemented in VideoController.cs.  For the
emulator, timings are rounded to the nearest cycle (so they're not 100% accurate)
although the new Scheduler/time-based scheme could be more precise.  A few micro-
seconds here and there won't appreciably alter the experience. ;-)


Vertical timing - both monitors:
1024 lines displayed
43 lines blanking
----
1067 lines

Horizontal - Portrait:      Landscape:
768 pixels displayed        1280 pixels displayed
244 blank                   422 blank
-----                       -----
1012 pixel clocks           1702 pixel clocks


Perq master clock = 5.89Mhz = ~170ns.  For emulation purposes, this is the rate
that dictates the timescale for our video timings, so:

Portrait:
Pixel clock = 64.78824 MHz = 15.44ns -> ~11:1 clock ratio = 92 cpu clocks/line
Visible field = 768 bit times * 15.44ns / 11 = ~70 pixel clocks
Horizontal retrace = 244 bit times * 15.44ns / 11 = ~22 pixel clocks

Landscape:
Pixel clock = 108.962 MHz = 9.1ns -> ~18.5:1 clock ratio = 92 cpu clocks/line!
Visible field = 1280 bit times * 9.1ns / 18.5 = ~70 pixel clocks
Horizontal retrace = 422 bit times * 9.1ns / 18.5 = ~22 pixel clocks


How It Works
------------

The display is maintained in Pascal/microcode by setting up a display list that
breaks down the vertical field into "bands" of up to 128 lines each.  Several
control bits, including a function code that sets the screen's background color
and a mixing function for the cursor image are programmed with a line count
(from 1..128) into the hardware's video registers.  As the hardware draws each
line on the display the line counter is decremented, triggering an interrupt
when it reaches zero.  The microcode must then immediately fetch and program the
values for the next band of the display; maximum latency is ~80 microinstructions
to avoid the risk of the display glitching or breaking up.

Vertical retrace is accounted for by the microcode setting up two bands
totalling 43 lines.  The second of these sets a bit which indicates the end of
the current display list (which, conveniently, is used to reset the scanline
counter).

The cursor image is moved about on screen by creating a band with the "cursor
enabled" bit set.  This band is up to 64 lines high and is programmed to start
"Y" lines into the frame.  The cursor's X position is rounded to the nearest
byte boundary and programmed into a dedicated register.  When the cursor is
enabled, the hardware mixes in the 8 bytes of the current line of the cursor
image when the "X" byte is reached.  The cursor and display bytes are blended
according to the raster function code programmed into the display list/video
control register.

Thus, the display list contains (at minimum) ten entries: 8 x 128 lines for the
visible field, and two entries for the vertical blanking field.  An additional
band is set up if the cursor is to be visible.  This means that at least ten
interrupts must be fielded by the microcode for every frame of the display, 60
times per second!  Ouch...

This is true even when the bottom part of the display is "turned off" -- a POS
feature that allows the system to temporarily use part of video memory for
large programs such as Scavenger or the compiler.  On a 2MB (or later, 4MB)
machine it seems silly to worry about an extra 96K of memory, but in a 256K
PERQ that's a fairly sizeable chunk.  Accent and PNX don't offer this, as their
window managers can't "resize" the screen dynamically, but it's a fun and
fairly unique feature of POS that adds to its quirky charm.  Because PERQemu
emulates the hardware, any OS or diagnostic/standalone program that programs
the control registers properly will run.


Subject to certain alignment restrictions, the display and cursor buffers may
reside anywhere in main memory.  The hardware automatically tracks the addresses
as each frame is drawn.  Animation effects or double-buffering the entire screen
are possible by changing the Display Address or Cursor Address registers before
the start of the frame.  Like the hardware it emulates, PERQemu does not check
the validity of addresses programmed into the registers.  Caveat microcodor?


Visual Bits
-----------

In PERQemu 0.4.6 the cursor/screen function bits are renamed to match the POS
documentation, as follows:

From io_others.pas:
    CursFunction = (CTWhite, CTCursorOnly, CTBlackHole, CTInvBlackHole,
                    CTNormal, CTInvert, CTCursCompl, CTInvCursCompl);
                    
From the POS Programming Examples:
    "The even functions have zeroes in memory represented as white and
    ones as black (this is the default: white background with black
    characters).  Odd functions have zeroes represented as black and
    ones as white.  The functions are as follows (inverted means screen
    interpretation; zeroes black, ones white):
    
    CTWhite:        Screen picture is not shown, only cursor.
    CTCursorOnly:   Same as CTWhite, only inverted.
    CTBlackHole:    This function doesn't work.
    CTInvBlackHole: This function doesn't work either.
    CTNormal:       Ones in the cursor are black, zeros allow the
                    screen to show through.
    CTInvert:       Same as CTNormal only inverted.
    CTCursCompl:    Ones in the cursor are XORed with screen,
                    zeros allow screen to show through.
    CTInvCursCompl: Same as CTCursCompl only inverted."

It seems a little dubious to try to faithfully emulate the video functions that
are described as "broken" by the machine's creators. :-)  The four that are
most commonly used work as advertised; the others may not look exactly right
until I've verified them on the actual hardware.


Moving to SDL2
--------------

As of PERQemu 0.4.6, the old WinForms display is dead.  The move to SDL2 for
the graphical display has a number of critical benefits:

    can run in 64 bits, which is required for newer versions of (at least)
    macOS that no longer provide 32-bit compatibility;

    is more platform independent, and free of the restrictions and
    performance issues with Mono's libgdiplus implementation;

    fixes the keyboard problems (busted key translations in Mono on the Mac);

    is much faster.  In theory.  In practice, so far?  Not so much. :-(

There are downsides, though:

    No viable higher level GUI toolkits means we only provide the basic
    display window;

    Packaging and bundling external libraries is maddeningly frustrating
    sometimes, when Mono can't find a .dll or .dylib that's in 38 places
    in the distribution and/or /Library/Frameworks or /opt or /usr/local
    or <bang shoots self in foot/head>;

    Uses a lot more memory.  Like, stupid amounts of memory.  Bloating up
    the 1bpp display to full 32-bit color and jamming 300MB/sec into the
    video card is just patently absurd.  But what can ya do.  "Progress."


VideoController.cs drives the video section of the PERQ, handling the registers
and state machine that tracks the horizontal and vertical video timings.  As
each scan line is completed, the 1bpp video (with cursor mixed in appropriately)
is handed off to Display.cs as a stream of bytes.  When the end of the visual
field is reached, a refresh operation is called to paint the completed frame
on screen.

Display.cs manages the 32bpp buffer that is copied from system memory into an
SDL texture (in GPU memory) and ultimately rendered to the display.  To help
speed this up -- in theory, anyway -- a table is generated at startup to map
a byte of pixel data from the PERQ into 8 x 32-bit pixels.  As the scanline
data is delivered from the VideoController, a simple table lookup-and-copy
"paints" 8 pixels at a time into the 32bpp buffer with no bit twiddling or
conditionals required.


Video Controller State Machine
------------------------------

Dramatically simplified?  Before we were managing all of the video state
transitions, but now the microcode does the work, which it's doing anyway! :-)

Two small corrections made:
    Bit 7 of the LineCount register is actually the "StartOver" bit!
    This is set when the second of the VBlank bands is programmed, and
    is now where we reset our scanline counter to the top of the field.

    The VBlank timing was too short - had to add in the HBlank AND the
    visible field.  Hey, a microsecond or two here and there can add up...

The state machine now starts in Idle mode.  The microcode sets up the Enable
bit first when it wants to access RAM, since the video refresh also performs
DRAM refresh.  This is the when the real hardware displays the rolling retrace
lines, as VBlank states aren't being set and interrupts which aren't being
generated are being ignored anyway. :-)  Once the memory sizing and test loop
is started, an actual display list is set up and we get to watch the kewl test
patterns roll by.

On the hardware, the screen then goes wobbly again until the system is loaded
and the Pascal/IO microcode takes over to set up the frame buffer and use the
screen.  I just have this itching to simulate that retrace graphically, to 
really make the experience that much more realistic. :-)  Since we now have to
render everything through a 32 bit frame buffer we might as well add some visual
sugar to sweeten the deal.

Meanwhile, the Idle state transitions when the EnableVideo bit is set; at this
point the first band should be programmed into the LineCount register and a
CursorFunction set.  When the _lineCounter goes to zero we raise the interrupt
and go back to Idle mode.  The CPU clears the interrupt by reprogramming the
LineCounter, then sets the flags to display another visual field OR enables the
transition to VBlank.  I think this is much less "creaky" and more faithful to
the real hardware.


The ScanLine Buffer
-------------------

Waaaay back I ran a bunch of tests to see if we could reduce the impact of
copying so much data around.  Even on 32-bit Mono it looked like looping over
12 quad words was substantially faster than zipping through 48 ushorts, and now
on 64-bits it seems to give a couple of fps bump.  So I went nuts and dragged
out the test code I'd introduced in the 0.4.5beta tree and dropped a stripped-
down version into Memory and VideoController.

Memory.cs now uses a Core struct to simulate a union type that can be accessed
by word or by quad word.  That is, all "normal" accesses through the FetchWord()
method work just as before, but the video can use FetchQuad() to grab bigger
chunks.  We can then zip through an entire scanline in 12 meaty slabs (portrait
display).  When the cursor is enabled, the old method of drawing the cursor
on top of the just-completed scanline is replaced by one unified loop.  It
still walks through 48 words, mixing in the cursor at the appropriate starting
byte.  This is slower but simpler, since it doesn't require a bunch of fussing
with masking or aligning the cursor bytes.  At most it's only done for 64 lines
out of the 1024 on the screen, so, feh.  I'll live with it for now.

On the receiving end, DrawScanline() now uses a pre-computed table to quickly
do pixel doub..qu..octoubling?  I like that, let's go with "octoubling".  For
each byte of PERQ pixel data, a simple table lookup provides eight 32-bit SDL
pixel values that are dropped into the 32bpp buffer.  Of course, the tradeoff
is that we burn more memory and bandwidth but avoid a bunch of shifts, masking
ops and a conditional for all 768 individual bits of each horizontal line
(1280 when I get Landscape going).  Is it actually worth it?  Are modern CPUs
with their large cache lines actually faster at bit banging this:
    p[i] = (i & (1 << b) == 0 ? foo : bar);
than this?
    p[i] = t[i, b];

Who knows?  Literally nobody knows.  It's an eternal mystery.  (NO I haven't
benchmarked it yet, it's just simpler and cleaner and it SHOULD be faster
even if it isn't, SO THERE.)


Other Stuff
-----------

Heh heh.  The first four CursorFunctions just show the cursor over a blank
screen.  This isn't terribly useful.  I can't remember the last time I tried
"login /cursorfunction=0" to see what happens on the actual hardware.  Hmm.

Had to wrap a lock() around the _interruptFlag because now with the Z80 on
its own thread, we actually do have to be careful about thread safety.  It
occurs to me that the far simpler/faster thing to do is make each interrupt
"pin" a separate value; for almost all of them the CPU just reads the flag
word to calculate priority (Vector setup) or condition code (IntrPend) and
occasionally spit out the current interrupt state on the console.  Every
device that raises and interrupt tends to be the one that also clears it, so
it avoids all that silly (read: slow) locking business by just eliminating
contention entirely.  VideoController can raise/clear the LineCounter intr
without worrying of the Z80 is mucking with the other flags at the same time.

Of course, if I wasn't developing this on a Mac that's still running Yosemite,
or if there's a Mono equivalent of .NET >= 5.0 available that'll run on it,
the Interlocked.Or() and Interlocked.And() methods look perfect for the task;
they're supposed to be lightning fast since they map directly to atomic cas
instructions in the processor (on x64, at any rate).  For now, stability is
more important than speed.  I'm still only getting 30fps with the CPU and SDL2
both running on the main thread.  Sigh.  More refactoring ahead...

Doh.  How did this turn into a blog entry?  Cripes.  More rewrites and cleanups
before any thought of submitting a pull request.

---
Last update: skeezics    Tue Oct 29 19:42:33 PDT 2021
