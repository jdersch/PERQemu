
The ExecutionController
=======================

Notes regarding how the management of the virtual machine is accomplished
through the ExecutionController.  Work in progress.


To allow for user interaction through the GUI, CLI or both (!) the PERQSystem
object is instantiated and managed by the ExecutionController.  The idea:

PERQemu
    -> Configurator
        User selects a pre-defined configuration, loads a saved one, or
        creates one of their own design.  Media files are assigned to the
        storage devices.  GUI and CLI work with Configurator to manipulate
        a Configuration object; they take care to validate the choices made
        to ensure the PERQ that's configured can actually be set up and run.
        When ready, this is passed to the ExecutionController.

    -> Controller
        In the GUI, a graphical representation of a PERQ2-style front panel
        provides a power on/off toggle, a reset button, and a rendering of
        the actual DDS to give simple visual feedback about the state of
        the machine.  Equivalent menu options are provided as well.  For
        most typical uses, this is sufficient; however, both a graphical
        Debugger and equivalent CLI commands allow for single stepping the
        main CPU (one microcycle at a time) or running single opcodes (one
        Q-code on the processor, or one Z80 instruction).  Pause and Run
        buttons/menu items and CLI "stop" and "start" commands give finer
        grained control.  All changes in the running state of the machine
        are managed by the ExecutionController.

    -> PERQSystem
        This is the nexus of the Emulator itself.  All of the parts of the
        virtual PERQ are attached here, based on the Configuration record.
        The ExecutionController is responsible for instantiating the actual
        PERQSystem object, starting it running, and managing the transitions
        between states on behalf of the GUI and CLI.  Inside the PERQSystem
        object, the major components are organized much like the actual
        hardware, from a top-level view:

        ->  a "CPU board" encompasses the processor and Scheduler, and runs
            the whole microengine and most of the primary controllers that
            make up the system; in Async mode it runs on its own thread.
        ->  the "memory board" is clocked directly by the CPU.  It includes
            the VideoController, which manages the PERQ frame buffer.
        ->  an "IO board" contains hard disk (and optionally Ethernet)
            controllers, as well as a Z80System object (see below).
        ->  if any optional IO devices are configured, an "Option board" is
            created to contain them all.  Three of the options are high
            priority: Ethernet, Canon printer, and streamer would be very
            nice to have, since schematics and code exist to aid in writing
            the emulation; over time, other rare or less-well documented
            hardware can be added.

        ->  Z80System
            This object encompasses what is essentially an independent
            single-board computer, running at its own clock rate (and with
            its own Scheduler).  Like the PERQSystem, Z80System manages a
            background thread to run a virtual Z80.  As in the actual PERQ
            hardware, asynchronous FIFOs and a pair of interrupt lines let
            the two processors communicate across clock domains.  Things
            get a little squirrely when it comes to DMA, but, happily, we
            don't yet rigorously enforce the full extent of the PERQ memory
            bus timings and limitations so for now this isn't an issue!  Ha!

            The Z80 thread runs all of the virtual Z80 I/O devices:  floppy
            controller, DMA, SIO and CTC chips, GPIB controller, keyboard,
            tablet, and audio output.  On the EIO, the RTC is also a Z80
            device, while on the PERQ-1 there's a tie-in to the Shugart hard
            disk controller for doing seeks.  We can sort of handwave over
            much of this for now.

        ->  Display
            Receives video data from the VideoController but runs on the
            main application/SDL thread.  All of the SDL2 interactions are
            managed here (including, for now, the host keyboard and mouse
            input).

Run Modes
---------

The original Z80 simulation ran on the main thread.   The new Z80 emulation can
run synchronously (in step with the CPU on one thread) or asynchronously (on a
thread managed by the IO Board which contains it).  For debugging, I've made
the mode applicable to both processors; instead of

> debug set z80 execution mode

we set up one overall mode with

> debug set execution mode

Asynchronous mode is likely to be the default and preferred mode in nearly every
situation going forward.  It may be useful for debugging to revert to synchronous
mode?  But any machine -- or VM environment -- with only a single CPU core isn't
likely going to meet the minimum requirements to even run .NET let alone PERQemu.


There's no need to maintain a long-running background thread for each processor
for all of the other RunStates -- single stepping, reset, and the intermediate
startup/shutdown states can all be managed synchronously.  When transitioning
to or from "Running" we start and stop the background threads, which in normal
usage provides the highest performance benefit.  All of the other modes are most
useful for debugging.

    ... except that the mapping state changes to events in a persistent
    thread running its own execution loop was simple and responsive, while
    every other way of doing this has proven to be an astronomical pain in
    the ass.


Run States
----------

When the GUI power button is toggled on, the controller tries to instantiate a
new PERQSystem object, based on the Configurator's current Configuration.  The
CLI equivalent is the "power on" command.  Because the Configurator does its
best to validate the user's choices and not allow impossible configurations to
be created, the power on request will generally only fail if an unimplemented
option is selected (so the situation should improve over time as emulation is
expanded to encompass more of the hardware).

The PowerOn method places the machine in a WarmingUp state which is where the
Display is created and the SDL2 machinery instantiated.  If SDL initialization
fails for any reason, it falls back to Off and reports the error.  During this
state media files are loaded and the virtual disks are spun up (for the real
masochist, we can simulate the actual start up time for each device, but this
can be turned off with Settings.Performance flags).

If the machine is started with the CLI "power on" command, it will remain in the
WarmingUp state until another command is issued.  The Display thread should
animate the screen coming to life with the "rolling retrace" lines while the
disks spin up to speed in the background.  Audio of that distinctive Shugart
shimmy, whine and rattle as it roars to life would be <kisses finterips> sweet.

To help untangle the dynamic creation of different Configurations, all of the
constituent parts of PERQSystem are (ideally) created without dependencies; the
Reset stage then actually tells each component to properly initialize itself
when all of the instance objects are loaded.  This may take some time to
achieve, given that there seem to be quite a few conflicts to resolve.  Reset
is also a transition state.

If the user setting PauseOnReset is true, the Reset state drops into Paused as
the emulator waits for the user to explicitly issue the next command.  If
PauseOnReset is false, Reset will immediately transition to Running.  Note that
a user-initiated Reset may occur at any time, pressing the virtual boot button
through a GUI representation/menu selection or the CLI "reset" command.

The Running state has to be as efficient as possible: in asynch mode, PERQsystem
sets both threads running, as the main application thread handles the SDL2
event loop.  And/or WinForms loop.  And/or polls the CLI every few milliseconds.
The synchronous version executes on the main thread, so on all but the fastest
hosts it'll probably struggle to maintain accurate emulation speeds.

The debugging run states, Step, Inst and Z80Inst can be transitioned to directly
from Paused or from Running.  In asynch mode, both Running threads are stopped,
as all of the single-step functions run synchronously.  The user may then type
or click through a sequence of steps, then return to the Running state with the
"start" (or "go") commands.

In synch mode, the user will have to break into Running with a ^C, or press the
equivalent "break" key when the display window has focus.  If a PERQ-1 is
configured, the "soft power down" feature may be invoked (the POS "bye off"
command) to shut down the virtual machine.  The only other way that the emulator
will stop is if an uncaught exception is thrown.  In this case, the Execution-
Controller or the Emulator itself will set the machine state to Halted, at which
point limited debugging may be possible.

When ready to end a session, the user can type "power off", press the power
button on the front panel display, or just click the close button on the Display
window.  This tells the ExecutionController to transition through ShuttingDown,
which closes the SDL2 window and shuts down the SDL2 event loop.  At this point
the PERQSystem state is set to Off -- but, crucially, the object is NOT yet
deallocated!

Saving modified hard disk or floppy disk images is governed by the "autosave"
Settings.  If set to No, nothing is done (though a warning may be printed?).
If set to Yes, the media files are updated in place.  If set to Maybe, the user
is asked (through a dialog box, ideally) whether they want to save or not only
if the image has been modified.  (In the case of hard disks this is silly since
you can't really do much without having the OS touch the swap space or update a
file's timestamp, but for floppies it's useful.  PERQmedia will apply a virtual
"write protect tab" on floppies by respecting the media file's mode bits.  For
hard disks the IsWritable flag might mean we force the user to supply another
filename so (for instance) images distributed with PERQemu don't get overwritten
or corrupted?


Events
------

There are so many "design patterns" that come and go, it's impossible to keep
up with what's in vogue anymore.  Transitioning PERQemu to an Event-driven
framework was one of many scenarios; I think the advantage was that (at least
with WinForms, which I was still messing with at the time) Events are naturally
dispatched on the appropriate thread without all the insane Begin/End/Invoke
stuff?  The basic idea is/was:

    RunStateChanged events are generated by the PERQSystem in response to
    updates from the ExecutionController.  The CPU and Z80 subscribe when
    they are instantiated.  The GUI (if present and active) can also
    subscribe so that it can respond to changes in the machine's state --
    regardless of which GUI toolkit is in use...  even the CLI could, in
    theory, capture events; for example, the PERQ-1 "soft" power off
    exception can be replaced with a RunStateChange event with PoweringDown
    as the argument.

    MachineStateChanged events would be mostly used by the Debuggers (when
    active).  Things like the DDS incrementing would provide a hook that
    the ExecutionController could use to simulate pressing the boot key,
    while the GUI would update the graphical DDS on the front panel.  The
    CLI could catch the DDS event and upate the Console.Title, taking one
    more Console.Writeline() out of CPU.cs!

Whether running in asynch or synch mode, the execution loop is pretty much the
same: loop until an "off" message tells the thread to exit.

Since WinForms is dead, the whole unmitigated nightmare of dealing with any
kind of cross-platform GUI is beyond rational discussion.  So long, useful
WindowsFormsSynchronizationContext keeping all that crap nicely hidden under
the covers.  Now we get to stand screaming into the abyss of libraries that
require controls be created and accessed on the main execution thread while
providing absolutely no means to make that easy or sane, and BEST of all there
are exactly _zero_ useful toolkits, widget sets, screen painters or any other
decent support for cross-platform GUIs even at the level of crappy ol' Winforms
without having to basically write three separate F*!#*$)ING front ends.  This
is sliding naked down the dull rusty razor of software development hell into a
vat of rubbing alcohol.  My dark vision of what should happen to 99.9% of all
software developers these days would make Genghis Khan blush.

So for now PERQemu has a CLI and a painfully kluged event loop that is only
run on the main thread when the processor is executing, and stopped when we
break to the console for debugging.  I have not yet achieved the perfect fugue
state of "dejected resignation" required to be okay with this.  Working on it.


Notes
-----

The Konamiman Z80's default ClockSynchronizer doesn't seem to regulate itself
well, if at all.  Using a 128-bit decimal type to specify the speed in Mhz is
21 times slower than a regular old floating point type.  Why.  WHY.  Massive
overkill.  Rather than mess with it we set the Z80's default ClockSynchronizer
to null and the PERQsystem/Z80system does the rate limiting.

To accomplish this, a SystemTimer object registers a periodic timer (with our
homegrown HighResolutionTimer) and a WaitHandle to provide a "heartbeat" every
n-milliseconds (initially every 10-20ms).  The number of instruction cycles the
processor should execute in that time is computed.  Each processor free runs
until that number of clock cycles is executed, then calls WaitForHeartbeat().
If the processor is running fast, it blocks until the timer fires, which clears
the wait and allows the thread to resume.  If the processor is running too slow
it continues without delay.  This simple strategy seems to work well with the
2.4576Mhz IOB Z80, where it regulates within +-1ns of the target rate.

I have no idea how we're supposed to program the Z80 devices to acknowledge
interrupts.  It's not like that's a thing, right?  Whatever.


State Machine
-------------

General rules:

Halted is the error state; it may be entered at any time and always stops the
processor(s) if running.  The only valid transition is to Off or Reset (which
may fail if it's a serious error).  This means non-fatal errors (such as trying
to load a floppy from a file that isn't readable, for example) should drop into
Paused so the user may try again.

The ShuttingDown state may be entered at any time.  It stops the machine and
shuts down the display, then transitions to Off.  The check for unsaved media
is made here; if a GUI is available, the "Save floppy <blah>" or "Save hard
disk <unit, file>" dialog is presented (subject to user preferences, of course)
or in the CLI a message is emitted for any modified and unsaved media.

    --> After a shut down, a Reset is required to re-enable the PROMs and
        restart the machine; this may be explicit or done implicitly as part
        of a subsequent "go" or "power on" command.  IF the machine config
        has not been modified, the loaded media should not be disturbed...

WarmingUp is a transitional state that is only invoked by the PowerOn() routine.
It always results in Halted (error on instantiation) or Reset.

Reset is a transitional stage.  It may be transitioned to from the WarmingUp
stage (machine successfully instantiated at power on) or it may be explicitly
called by the user from any state besides ShuttingDown/Off.

All other state transitions should be codified in the TransitionTo() routine.
Which they have been.  Weirdly.  I've gotta fix my brain.


Bottom line:

    ALL of the ExecutionController interactions with PERQSystem (and the
    Z80System) have to be substantially revisited and refined.  This is
    all likely to change again until I've got it right, or die trying.


--
Last update: skeezics    Mon Jan 31 13:34:45 PST 2022
