
Streamer Notes
==============

These notes are an in-depth description of the QIC tape emulation added in
PERQemu v0.4.8.  This supplements the technical documentation in the Hardware
References folder (with more detailed documentation and specs from Archive
Corporation available on Bitsavers).  The streamer is supported on the PERQ-1
now, and will be available in PERQ-2 configurations when available.

See the UserGuide.pdf for more information about using the PERQ's streamer
utility to load and save tape images.


An Emulation in Three Halves
----------------------------

Support for the Archive "Sidewinder" streaming tape drive is broken into two
parts:  the PERQ controller is a very thin layer between the IO Option board
(OIO) and the intelligent controller built into the external drive.  Initially
it will support the 3020I model, providing 20MB of storage per tape (equivalent
to a DC-300XL 1/4" cartridge) and use the drive's rated 30 inches/second (IPS)
speed and transfer rate.  There are no apparent limitations in the microcode or
Pascal library that would preclude emulation of the 9020I (90IPS, 20MB) or the
9045I (90IPS, 45-60MB) to provide more storage and higher transfer rates.  More
on performance below.

Two implementations of the PERQ interface are supported: the most common is the
"wire-wrap version" which is optionally included on the OIO board.  Because the
streamer does not use DMA it can be used in the CPU Option slot as well, so
(like the PERQ Link) it is a "universal" option.  The second implementation is
built into the Multibus/Laser Option (MLO) board.  Some partial schematics have
been found for the OIO version, and it's likely that the MLO version is nearly
identical.

The PERQ side of the interface is Emulator/IO/TapeDevices/QICTapeController.cs.

The implementation is based on TSIO.micro (OIO driver).  TMIO.micro (MLO driver)
only differs by two addresses and the interpretation of two bits in the status
register, which lets the microcode determine which interface board is present.
The microcode drives all data transfer _and_ timing by directly manipulating
the control lines, so for emulation this means the PERQ side is almost entirely
a simple matter of translating register writes into "edges" that the emulated
drive interprets to initiate commands; a single 8-bit bi-directional data latch
is the "bus" between the two.

The drive side of the interface is in Emulator/IO/TapeDevices/Sidewinder.cs.

Halfway through the implementation it was clear that separating the drive and
controller into distinct parts (like the FloppyDisk/NECuPD765 implementation)
would help keep the code more manageable.  So a third "half" (CartridgeTape.cs)
provides the mechanical ops and wraps the underlying StorageDevice, while the
intelligent controller is emulated by the Sidewinder class. 

The physical drive is built to fit the same mechanical dimensions as the Shugart
8" floppy drives, and in theory (assuming the mounting holes line up) you could
replace the SA851 with a 3020I inside the cabinet, but for emulation purposes we
assume that the streamer is an external add-on.  Like the floppy the QIC-02 bus
protocol and electrical interface can attach from 1-4 drives in a string.  But
as with the floppy implementation, the PERQ only supports one drive at the
default address (drive select 0, or "unit #3" in PERQemu configurations).

The command set is very simple, but the extremely low-level interface makes it
cumbersome to implement.  There are seven commands issued by the controller.
Because the PERQ's microcode directly drives the signal lines, emulation of the
hardware's "handshake" has to conform to the expected time delays built into the
drive's specs; the microcode looks for transitions of the status lines to signal
acknowledgements of data transfers.

Three documents guide the hardware emulation strategy:
    Archive_Sidewinder_TheoryOpn.pdf, Rev C 8/16/82 (a copy in Docs)
    Archive_Sidewinder_ProdDescr.pdf, Rev E 10/7/82
    Archive_Sidewinder_MaintMan.pdf, P/N 20109-001B, 1982

The emulator strives to be accurate, but hews to the actual PERQ microcode's
expectations in cases where ambiguities or discrepancies arise.  To make the
drive more responsive to emulator users, some shortcuts are allowed where the
timing of commands has some flexibility (i.e., the long Erase, Rewind or Re-
tension commands); this is governed by the "TapeSpeed" rate limiting option.


Shaky hands
-----------

The PERQ "controller" drives four output signals tied to bits in the control
register:  RESET, REQUEST, ONLINE, and XFER.  It receives responses from the
drive on three lines, passed to the microcode through the status register:
READY, EXCEPTION, and ACK.  The 8-bit data bus allows one byte at a time to be
passed back and forth; the DIRC signal in the hardware directly drives the
direction pin on a 'LS245 latch that holds the data or control/status byte 
being exchanged but it isn't exposed to the software and is not emulated here.

Two sets of handshaking lines are used, implemented by state machines on the
drive side.  Commands are always initiated by the host, and the REQUEST/READY
signal pair mediates the exchange.  When a data transfer (read or write) is
initiated, the XFER/ACK lines are used, as this distinguishes the transmission
of data rather than command bytes.  ONLINE is used only during read or write
commands, to signal when the host is finished with a given operation.

RESET has its own protocol steps, but for simplicity the emulator "cheats" and
makes this a direct, asynchronous event rather than follow another unique set
of timings.  I think we can get away with this since the microcode "knows" to
wait for the drive, and what's 13 microseconds between friends?

The state machine Phase encodings capture the four "edges" of a command byte
write from the host.  Each time the microcode toggles a control bit the drive's
CheckSignals method advances through the state machine phases necessary to read
the command byte and take the appropriate action.  Responses through the status
lines are simply written to the register; the microcode handles the PERQ's half
of the handshake so the QICTapeController doesn't have much work to do!  The
overall state of the drive is represented by a DriveState:  Idle, Busy, etc.
The drive accepts only one command at a time.  Unlike the floppy controller,
the tape drive doesn't _require_ a status read after every command; the host is
allowed to ask for status (to read error counters or flags if it wants to) but
only a few exceptional conditions require it.

The Read Status command follows most of the same handshaking steps as the other
commands, but the EXCEPTION line is used to alert the host that it is required.
During fault or exception conditions, no other command but Read Status is
accepted by the controller.  To complicate things a bit, the READY signal is
inverted for this exchange.  When selected, Read Status advances the Phase to a
separate set of states used to regulate the transfer of a status buffer to the
host.  Like the FDC or GPIB controllers, a tape status read returns six bytes
with specific information:  two bytes of flags, two bytes of error count, and
two bytes with underrun information.

    Note about error handling:  Currently the VERY complex tape error/retry
    handling is not implemented; virtual tapes are basically perfect and
    never wear out.  We do track bad blocks read from the archive, however,
    but it's not clear if error handling will be necessary at the emulator
    since it operates at the block level and we could largely ignore those
    blocks.  The "intelligent" controller in the Archive drive never exposes
    the host to flux transitions, gaps, CRC bytes, or any of the actual low-
    level information as it comes off the tape; a block is always 512 bytes
    and is "good" or "bad".

The XFER/ACK lines are used to pace the transfer of data bytes during the Read
or Write commands; the RQST/RDY lines are still available to inject new commands
during a WriteData/WriteFileMark or ReadData/ReadFileMark sequence.  These are
complicated enough that each is explained separately, below.

A single "protocol event" is used to schedule callbacks for signal changes from
the controller.  The Streamer runs in the CPU thread so concurrency issues are
ignored throughout, and yes my fingers are in my ears and I'm shouting "Lalala
I can't hear you I can't hear you!"  The microcode drives transitions from the
host (PERQ) side, calling the drive's CheckSignals() method when it writes to
the control register.  We don't enforce timing restrictions in the Sidewinder
implementation, assuming that if the microcode is violating protocol then it
wouldn't work on the hardware and surely somebody would have noticed that, hmm?
Thus, the drive catches signal changes, updates its state, then schedules the
appropriate response to fire according to the state diagrams/documentation.
The microcode polls the status and reacts accordingly, which is why we can't
cheat on some signals (and can bend others to make the drive run faster when
rate limiting is turned off).


Mechanical emulation
--------------------

The basic 3020I drive is "baked-in" so that like the floppy drive, PERQemu has
a baseline configuration for the empty drive when first starting up.  Like the
floppy, it assigns DeviceGeometry.NoMedia to the empty drive when no cartridge
is loaded.

The OnLoad() hook sets up new media and resets the Geometry and performance
Specs from the loaded file.  "Archive20" media is the default 20MB tape for the
3020I (30IPS) drive.  Since the software doesn't seem to have any difficulty
with the faster 9020I (90IPS) rate, turning off the TapeSpeed rate limit with
the "settings rate limit" command uses the 90IPS specs.  Note that by definition
the 30IPS drive runs at 90IPS for positioning operations.

The Archive45 and Archive60 formats are included in the device configuration
database to simulate the 9045I drive.  This is a 90IPS Sidewinder model that
uses 9 tracks instead of 4, yielding capacities of 45MB on a 450' DC-300XL or 
60MB on a 600' DC-600A.  Preliminary testing shows that these work fine, but
the 24MB limit of the Shugart hard drive / PERQ-1 configuration doesn't allow
for testing the full capacities.

Specs (the DevicePerformance record) are interpreted a little differently than
for disk drives; these are documented in the source code, and the "storage show"
command has been updated to display the tape drive info accurately. :-)

A separate "motion event" in Sidewinder.cs is used to schedule tape start and
stop operations (100-300ms, an eternity) as well as sector timing for streaming
during transfers.  The built-in controller on the drive provides three fixed
512-byte data buffers: for writes, this lets the host fill a buffer while the
drive is writing the previous one to tape, and the read head is then verifying
the data immediately after it is written.  For reads this allows the drive to
read ahead while the host transfers data (polled on the PERQ, but designed to
operate at DMA speeds).  At 90IPS, the complete sector timing is 5.91ms (which
accounts for physical tape headers, which aren't exposed to the host in the
hardware or in the emulator).  The 30IPS drive runs at a sedate 17.73ms/sector.


Errors, Underruns and Faults
----------------------------

Exceptional conditions aren't really dealt with, yet.  Underruns are counted on
writes and the tape stopped; when the next full buffer is available, Flush() is
called to start up the capstan motor again and start the "write behind" action.
It seems that Stut (in POS or Accent) doesn't really attempt to interleave the
hard disk and tape accesses, even though the disk uses DMA and should be able
to run concurrently with the polled I/O bus-connected streamer.  Stut will read
a bunch of disk blocks into a memory pool, then tell the microcode to blast 'em
all to the streamer.  Then the streamer pauses/spins down waiting for the next
Write command while the PERQ refills the disk buffers.  The "washboard effect"
in real life usage is annoying; at least under emulation (without any audio
effects :-) you don't get the whirrrrrr-pause-whirrrrrr cycle and the virtual
drive never suffers from mechanical wear, although I _have_ considered sneakily
having the PRQM media format store a "power on hours" counter and start tossing
out correctable errors occasionally to make the emulation more authentic... :-]

So for now, the emulated streamer uses defect-free tapes that never wear out or
produce data errors from head drift or oxide buildup on the heads, and the very
complex read-after-write-to-verify-CRCs is unimplemented so blocks are never
rewritten after write errors.  If the data written into the .tap file from a
real tape contains error information I do attempt to preserve it, but that has
not been an issue yet.  Obviously attention will be paid as the need arises.


Internal Implementation Notes
-----------------------------

I'm just resigned to the fact that at this stage in my life and career, "not
_too_ shabby" is the high water mark when it comes to my coding.  That said,
in case anyone ever wants to delve into this monstrosity in the future, here
are a few words about the basic structure.

QICTapeController is super straightforward; it has "no moving parts" and just
funnels command, status and data bytes between the microcode and the Sidewinder.
The finicky part is the interplay between the two halves of the drive itself.
CartridgeTape.cs is now the wrapper around the StorageDevice and it alone does
all of the serializing of tape blocks between the controller and the media.  I
did away with the fixed array of buffers in the controller and instead use a
Queue<> that shuffles BlockBuffers between the two.  Because all parts of the
streamer run in the same thread as the CPU and Scheduler, there are no worries
about concurrency.  It is a fairly low-volume, low-use, low-demand device so
performance isn't a huge concern.  (Remember, "never underestimate the bandwidth
of a station wagon full of magtapes!")

Essentially there is one active buffer for dealing with the block _currently_
being written to or from the host.  The BlockBuffer provides a thin shell and
some accessors that simplify byte access for the controller.  Completed blocks
to be written to tape are then queued for the mechanism, which runs a "write
behind" scheme to approximate the streaming nature of the hardware: the motor
is spun up to speed and the drive expects to pop a full block off the queue to
spool it to tape every 17.73msec (or 5.91msec in 90ips mode).  If starved of
blocks it spins down the motor and waits for the controller to Flush() another
block.  Similarly, the "read ahead" process works in the opposite direction,
where the drive starts reading full blocks from the tape and queuing them up
for the host.  As the controller and microcode do their little byte exchange
handshaking dance, it pops blocks off the queue to make room for new ones.  As
with the writer, the reader will spin down the motor if the host can't keep up,
and a Fetch() call when the host is hungry again restarts the process.

While the hardware has three fixed buffers, I have been playing with bumping
that number up to see if the system can handle the 90ips rate.  Five buffers
is a pretty reasonable compromise but a LOT more testing and tuning remain.
Because efficiency isn't the utmost priority, running the profiler while the
tape is transferring blocks would likely make strong men weep for all the data
copying and memory allocation and GC going on.  Someday I'll have to sit down
and really understand how C# references work and make this thing way cleaner,
but that day is not today...


BUGS
----

The microcode (TSIO.micro for POS, v2.8; TSIO.micromac for Accent v0.2) does NOT
follow the specification in at least one significantly erroneous way.  The drive
is supposed to write a final file mark and automatically rewind when the "end of
write" sequence is initiated by the host.  But the PERQ microcode doesn't rely 
on, or seemingly even expect the drive to do that; in fact, they don't use that
"feature" at all.  Rather than just drop the Online signal to say "done writing"
they write three consecutive filemarks then IMMEDIATELY issue a ReadStatus -- 
without waiting for the Ready response from the drive to indicate that the
previous WriteFM command was completed.  They drop the Online signal *after*
initiating the ReadStatus command!  Finally, the TSWrEnd routine explicitly
issues a rewind command that would be completely superfluous if they just let
the controller handle that automatically it as it's supposed to.  Ugh.

The cryptic comment in the source that the "drive doesn't rewind if the last
command was a Read Status" is either a complete misinterpretation of the spec --
there's NO such documented behavior -- or it's based on observations of behavior
from the drive's firmware that doesn't match the spec.  Either way, the emulator
has to deal with one OR BOTH of these being true.

By not using the SendCmd microroutine to transition from the final WriteFileMark
to ReadStatus, it means the emulator has to see that the microcode has already
made the transition (raising RQST while still ONLINE, then dropping ONLINE and
RQST to pass the ReadStatus command byte) and abandon the documented "end of
write" behavior.  To work around this illegal state machine transition, the
least egregious path for the emulator is to latch the command byte, spoof the
RDY signal to let the microcode think that the normal handshake completed, then
allow WriteFileMark to complete before jumping straight into sending back the
first status byte.  The Accent version seems to have the same problem, but adds
an additional wait state to try to compensate -- so they clearly must have
identified a problem but completely misunderstood the necessary fix (or the
opportunity to simplify the code by using the "end of write" sequence properly).

Sigh.  Bug compatibility is fun.


Performance
-----------

On paper, the Sidewinder 3020I streams data at an average speed of 28.9KB/sec.
Yes, that's half the speed of the SA851 floppy drive's rated 62.5KB/sec.  The
9020I and 9045I drives haul the mail at 86.7KB/sec which won't exactly break
any Guinness Book records but it's at least tolerable.  While the initial goal
of the emulation is 100% accuracy (to verify that all the PERQ software can use
the drive as designed), already there are some benefits built-in to disabling
the TapeSpeed rate limit option.  In addition, the tape controller's buffer
count is a simple compile-time constant that I may turn into a tunable runtime
parameter (or, after a bunch more testing, may tune according to the rate limit
setting).  Tested with the "stock" 3 buffers, or increased to as many as 8, no
real performance numbers are yet available; only when all the scaffolding in
place for debugging is removed can a Release build be speed tested and some
data collected.  Still, loading ONE tape is way more convenient than loading 20
floppies one after the other, or it will be once I figure out how to prepare
some OS load images and include 'em in the distribution...


Schematics
----------

Found some old photocopies of the "Streamer Packet" that describes how to build
the wire wrapped version of the interface.  Included were "old streamer board"
and "new streamer board" partial schematics.  The "new" version seems to most
closely resemble the microcode's view of things.  Of note, however, is a signal
that would indicate an interrupt (using the "X" vector) could be enabled when
the drive raises either the Ready or Exception lines!  However, there is zero
evidence that this was ever supported in software.  Strange.

This is something that would be worth scanning and putting in the archives for
anyone who wants to build a streamer board (it's only about a dozen ICs and
some wire wrap sockets) although finding drives and QIC media that haven't gone
completely to rot is increasingly difficult these days...


---
Last update: skeezics    Wed Dec 28 01:22:37 PST 2022
